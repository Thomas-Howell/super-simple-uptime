import "dotenv/config";
import process from "node:process";
import { mkdir, readdir, writeFile } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { createRequire } from "node:module";
import { z } from "zod";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const backendRoot = path.resolve(__dirname, "..");
const typesDir = path.join(backendRoot, "src", "types");
const dtosDir = path.join(backendRoot, "src", "controllers", "dtos");

const require = createRequire(import.meta.url);
const jiti = require("jiti")(import.meta.url, {
  cache: false,
  esmResolve: true,
  extensions: [".ts", ".tsx", ".js"],
  alias: {
    "@src": path.join(backendRoot, "src"),
  },
});

const header = `// Auto-generated by scripts/createDtos.js. Do not edit directly.\n`;

const TYPE_NAME_MAP = new Map();

const aliasTypeName = (raw, normalized) => {
  if (raw && typeof raw === "string") {
    TYPE_NAME_MAP.set(raw, normalized);
  }
};

aliasTypeName("ZodString", "string");
aliasTypeName("string", "string");
aliasTypeName("ZodNumber", "number");
aliasTypeName("number", "number");
aliasTypeName("ZodBoolean", "boolean");
aliasTypeName("boolean", "boolean");
aliasTypeName("ZodBigInt", "bigint");
aliasTypeName("bigint", "bigint");
aliasTypeName("ZodDate", "date");
aliasTypeName("date", "date");
aliasTypeName("ZodEnum", "enum");
aliasTypeName("enum", "enum");
aliasTypeName("nativeEnum", "enum");
aliasTypeName("ZodLiteral", "literal");
aliasTypeName("literal", "literal");
aliasTypeName("ZodArray", "array");
aliasTypeName("array", "array");
aliasTypeName("ZodUnion", "union");
aliasTypeName("union", "union");
aliasTypeName("ZodDiscriminatedUnion", "union");
aliasTypeName("discriminatedUnion", "union");
aliasTypeName("ZodObject", "object");
aliasTypeName("object", "object");
aliasTypeName("ZodNull", "null");
aliasTypeName("null", "null");
aliasTypeName("ZodUndefined", "undefined");
aliasTypeName("undefined", "undefined");
aliasTypeName("ZodAny", "any");
aliasTypeName("any", "any");
aliasTypeName("ZodUnknown", "unknown");
aliasTypeName("unknown", "unknown");
aliasTypeName("ZodNever", "never");
aliasTypeName("never", "never");
aliasTypeName("ZodVoid", "void");
aliasTypeName("void", "void");
aliasTypeName("ZodOptional", "optional");
aliasTypeName("optional", "optional");
aliasTypeName("ZodNullable", "nullable");
aliasTypeName("nullable", "nullable");
aliasTypeName("ZodDefault", "default");
aliasTypeName("default", "default");
aliasTypeName("ZodEffects", "effects");
aliasTypeName("effects", "effects");
aliasTypeName("ZodReadonly", "readonly");
aliasTypeName("readonly", "readonly");
aliasTypeName("ZodCatch", "catch");
aliasTypeName("catch", "catch");
aliasTypeName("ZodPrefault", "prefault");
aliasTypeName("prefault", "prefault");
aliasTypeName("ZodPipeline", "pipeline");
aliasTypeName("pipeline", "pipeline");
aliasTypeName("ZodPromise", "promise");
aliasTypeName("promise", "promise");

const firstPartyKind = z?.ZodFirstPartyTypeKind || z?.z?.ZodFirstPartyTypeKind;
if (firstPartyKind && typeof firstPartyKind === "object") {
  aliasTypeName(firstPartyKind.ZodString, "string");
  aliasTypeName(firstPartyKind.ZodNumber, "number");
  aliasTypeName(firstPartyKind.ZodBoolean, "boolean");
  aliasTypeName(firstPartyKind.ZodBigInt, "bigint");
  aliasTypeName(firstPartyKind.ZodDate, "date");
  aliasTypeName(firstPartyKind.ZodEnum, "enum");
  aliasTypeName(firstPartyKind.ZodNativeEnum, "enum");
  aliasTypeName(firstPartyKind.ZodLiteral, "literal");
  aliasTypeName(firstPartyKind.ZodArray, "array");
  aliasTypeName(firstPartyKind.ZodUnion, "union");
  aliasTypeName(firstPartyKind.ZodDiscriminatedUnion, "union");
  aliasTypeName(firstPartyKind.ZodObject, "object");
  aliasTypeName(firstPartyKind.ZodNull, "null");
  aliasTypeName(firstPartyKind.ZodUndefined, "undefined");
  aliasTypeName(firstPartyKind.ZodAny, "any");
  aliasTypeName(firstPartyKind.ZodUnknown, "unknown");
  aliasTypeName(firstPartyKind.ZodNever, "never");
  aliasTypeName(firstPartyKind.ZodVoid, "void");
  aliasTypeName(firstPartyKind.ZodOptional, "optional");
  aliasTypeName(firstPartyKind.ZodNullable, "nullable");
  aliasTypeName(firstPartyKind.ZodDefault, "default");
  aliasTypeName(firstPartyKind.ZodEffects, "effects");
}

const getRawSchemaType = (schema) => {
  if (!schema) {
    return undefined;
  }

  const def = schema._def || schema.def;
  return (
    def?.typeName || def?.type || schema.typeName || schema.constructor?.name
  );
};

const getSchemaType = (schema) => {
  const rawType = getRawSchemaType(schema);
  return rawType ? TYPE_NAME_MAP.get(rawType) || rawType : undefined;
};

const escapeStringLiteral = (value) =>
  value.replaceAll("\\", "\\\\").replaceAll("'", "\\'");

const toPascalCase = (value) =>
  value
    .replace(/([a-z0-9])([A-Z])/g, "$1 $2")
    .replace(/[_-]+/g, " ")
    .split(/\s+/)
    .filter(Boolean)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join("");

const deriveDtoName = (exportName) => {
  const base = exportName.replace(/Schema$/, "");
  return `${toPascalCase(base || exportName)}Dto`;
};

const makeAliasName = (interfaceName, propertyPath) => {
  if (propertyPath.length === 0) {
    return undefined;
  }

  const suffix = propertyPath.map((segment) => toPascalCase(segment)).join("");
  return `${interfaceName}${suffix}Type`;
};

const formatLiteral = (value) => {
  switch (typeof value) {
    case "string":
      return `'${escapeStringLiteral(value)}'`;
    case "number":
      return `${value}`;
    case "bigint":
      return `${value}n`;
    case "boolean":
      return value ? "true" : "false";
    default:
      return value === null ? "null" : JSON.stringify(value);
  }
};

const createTypeAlias = (aliasName, values, includeNull) => {
  const uniqueValues = [...new Set(values.map(formatLiteral))];
  const union = uniqueValues.join(" | ") || "never";
  const nullSuffix = includeNull ? " | null" : "";
  return `export type ${aliasName} = ${union}${nullSuffix};`;
};

const mergeTypeParts = (left, right) => {
  const seen = new Set([...left, ...right]);
  return [...seen];
};

const isZodObject = (candidate) => getSchemaType(candidate) === "object";

const collectTypeFiles = async (dir) => {
  const entries = await readdir(dir, { withFileTypes: true });
  const files = [];

  for (const entry of entries) {
    const entryPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      if (entry.name === "dtos") {
        continue;
      }

      files.push(...(await collectTypeFiles(entryPath)));
      continue;
    }

    if (
      entry.isFile() &&
      entry.name.endsWith(".ts") &&
      !entry.name.endsWith(".d.ts")
    ) {
      files.push(entryPath);
    }
  }

  return files;
};

const discoverSchemaSources = async () => {
  const typeFiles = (await collectTypeFiles(typesDir)).sort();

  return typeFiles.map((filePath) => {
    const modulePath = path
      .relative(__dirname, filePath)
      .split(path.sep)
      .join("/");
    const outputPath = path.join(dtosDir, path.relative(typesDir, filePath));

    return {
      modulePath,
      output: outputPath,
    };
  });
};

const analyzeSchema = (schema, context = {}) => {
  const { registerLiteralUnion, propertyPath = [], nullable = false } = context;

  const rawTypeName = getRawSchemaType(schema);
  const typeName = getSchemaType(schema);

  if (!typeName) {
    if (schema?._def?.innerType) {
      return analyzeSchema(schema._def.innerType, context);
    }
    if (schema?._def?.schema) {
      return analyzeSchema(schema._def.schema, context);
    }
    throw new Error("Unable to determine schema type for DTO generation");
  }

  let result;

  switch (typeName) {
    case "optional": {
      const innerSchema = schema?._def?.innerType;
      if (!innerSchema) {
        throw new Error("Optional schema is missing inner type definition");
      }
      const inner = analyzeSchema(innerSchema, context);
      result = { ...inner, optional: true };
      break;
    }
    case "nullable": {
      const innerSchema = schema?._def?.innerType;
      if (!innerSchema) {
        throw new Error("Nullable schema is missing inner type definition");
      }
      return analyzeSchema(innerSchema, {
        ...context,
        nullable: true,
      });
    }
    case "default": {
      const innerSchema = schema?._def?.innerType;
      if (!innerSchema) {
        throw new Error("Default schema is missing inner type definition");
      }
      return analyzeSchema(innerSchema, context);
    }
    case "effects": {
      const innerSchema = schema?._def?.schema;
      if (!innerSchema) {
        throw new Error("Effects schema is missing inner schema definition");
      }
      return analyzeSchema(innerSchema, context);
    }
    case "catch":
    case "prefault":
    case "readonly":
    case "pipeline": {
      const innerSchema =
        schema?._def?.innerType ||
        schema?._def?.schema ||
        schema?._def?.out ||
        schema?._def?.in;
      if (!innerSchema) {
        throw new Error(
          `Unsupported Zod wrapper type: ${rawTypeName || typeName}`
        );
      }
      return analyzeSchema(innerSchema, context);
    }
    case "promise": {
      const innerSchema = schema?._def?.innerType;
      if (!innerSchema) {
        throw new Error("Promise schema is missing inner type definition");
      }
      const innerInfo = analyzeSchema(innerSchema, context);
      const innerType =
        innerInfo.typeParts.length === 1
          ? innerInfo.typeParts[0]
          : `(${innerInfo.typeParts.join(" | ")})`;
      result = {
        typeParts: [`Promise<${innerType}>`],
        optional: innerInfo.optional ?? false,
        includesNull: innerInfo.includesNull ?? false,
      };
      break;
    }
    case "string":
      result = { typeParts: ["string"], optional: false, includesNull: false };
      break;
    case "number":
      result = { typeParts: ["number"], optional: false, includesNull: false };
      break;
    case "boolean":
      result = { typeParts: ["boolean"], optional: false, includesNull: false };
      break;
    case "bigint":
      result = { typeParts: ["bigint"], optional: false, includesNull: false };
      break;
    case "date":
      result = { typeParts: ["Date"], optional: false, includesNull: false };
      break;
    case "enum": {
      const def = schema?._def;
      const rawValues = Array.isArray(def?.values)
        ? def.values
        : def?.values && typeof def.values === "object"
          ? Object.values(def.values)
          : def?.entries && typeof def.entries === "object"
            ? Object.values(def.entries)
            : Array.isArray(def?.entries)
              ? def.entries
              : [];

      if (
        registerLiteralUnion &&
        propertyPath.length > 0 &&
        rawValues.length > 0
      ) {
        const stringValues = rawValues.filter(
          (value) => typeof value === "string"
        );
        if (stringValues.length > 0) {
          const aliasName = registerLiteralUnion(
            propertyPath,
            stringValues,
            nullable
          );
          if (aliasName) {
            result = {
              typeParts: [aliasName],
              optional: false,
              includesNull: nullable,
            };
            break;
          }
        }
      }

      const unionValues = rawValues.map((value) =>
        typeof value === "string" ||
        typeof value === "number" ||
        typeof value === "bigint"
          ? formatLiteral(value)
          : JSON.stringify(value)
      );
      result = {
        typeParts: unionValues,
        optional: false,
        includesNull: false,
      };
      break;
    }
    case "literal": {
      const def = schema?._def ?? {};
      const literalValue =
        "value" in def
          ? def.value
          : Array.isArray(def.values)
            ? def.values[0]
            : undefined;
      const formatted = formatLiteral(literalValue);
      result = {
        typeParts: [formatted],
        optional: false,
        includesNull: literalValue === null,
      };
      break;
    }
    case "array": {
      const elementSchema = schema?._def?.element || schema?._def?.type;
      if (!elementSchema || typeof elementSchema === "string") {
        throw new Error("Array schema is missing element definition");
      }
      const elementInfo = analyzeSchema(elementSchema, context);
      const elementType =
        elementInfo.typeParts.length === 1
          ? elementInfo.typeParts[0]
          : `(${elementInfo.typeParts.join(" | ")})`;
      result = {
        typeParts: [`${elementType}[]`],
        optional: elementInfo.optional ?? false,
        includesNull: false,
      };
      break;
    }
    case "union": {
      const options = schema?._def?.options
        ? [...schema._def.options]
        : schema?._def?.optionsMap instanceof Map
          ? [...schema._def.optionsMap.values()]
          : [];
      const optionInfos = options.map((option) =>
        analyzeSchema(option, context)
      );
      const optional = optionInfos.some((info) => info.optional);
      const typeParts = optionInfos.reduce(
        (acc, info) => mergeTypeParts(acc, info.typeParts),
        []
      );
      const includesNull = optionInfos.some((info) => info.includesNull);
      result = { typeParts, optional, includesNull };
      break;
    }
    case "object": {
      const shape =
        typeof schema.shape === "function" ? schema.shape() : schema.shape;
      const entries = Object.entries(shape).map(([key, value]) => {
        const info = analyzeSchema(value, {
          registerLiteralUnion,
          propertyPath: [...propertyPath, key],
        });

        const unionParts = info.typeParts.filter(
          (part) => part !== "undefined"
        );
        const union =
          unionParts.length === 0
            ? "unknown"
            : unionParts.length === 1
              ? unionParts[0]
              : unionParts.join(" | ");
        return `    ${key}${info.optional ? "?" : ""}: ${union};`;
      });

      const typeLiteral = `{
${entries.join("\n")}
  }`;
      result = {
        typeParts: [typeLiteral],
        optional: false,
        includesNull: false,
      };
      break;
    }
    case "null":
      result = { typeParts: ["null"], optional: false, includesNull: true };
      break;
    case "undefined":
      result = {
        typeParts: ["undefined"],
        optional: true,
        includesNull: false,
      };
      break;
    case "any":
      result = { typeParts: ["any"], optional: false, includesNull: false };
      break;
    case "unknown":
      result = { typeParts: ["unknown"], optional: false, includesNull: false };
      break;
    case "never":
      result = { typeParts: ["never"], optional: false, includesNull: false };
      break;
    case "void":
      result = { typeParts: ["void"], optional: false, includesNull: false };
      break;
    default: {
      if (schema?._def?.innerType) {
        return analyzeSchema(schema._def.innerType, context);
      }
      if (schema?._def?.schema) {
        return analyzeSchema(schema._def.schema, context);
      }
      if (schema?._def?.out) {
        return analyzeSchema(schema._def.out, context);
      }
      throw new Error(`Unsupported Zod type: ${rawTypeName || typeName}`);
    }
  }

  if (nullable && !result.includesNull) {
    result = {
      ...result,
      typeParts: mergeTypeParts(result.typeParts, ["null"]),
      includesNull: true,
    };
  }

  return result;
};

const buildInterface = (schema, interfaceName) => {
  if (!isZodObject(schema)) {
    throw new Error(`Schema for ${interfaceName} must be a ZodObject`);
  }

  const typeAliasRegistry = new Map();
  const usedAliasNames = new Set();

  const registerLiteralUnion = (propertyPath, values, includeNull) => {
    if (propertyPath.length === 0) {
      return undefined;
    }

    const key = `${propertyPath.join(".")}::${values.join("|")}::${includeNull ? "1" : "0"}`;
    if (typeAliasRegistry.has(key)) {
      return typeAliasRegistry.get(key).name;
    }

    const suggestedName =
      makeAliasName(interfaceName, propertyPath) || `${interfaceName}Type`;
    let candidate = suggestedName;
    let counter = 1;
    while (usedAliasNames.has(candidate)) {
      candidate = `${suggestedName}${counter}`;
      counter += 1;
    }

    usedAliasNames.add(candidate);
    typeAliasRegistry.set(key, {
      name: candidate,
      values: [...values],
      includeNull: includeNull === true,
    });
    return candidate;
  };

  const shape =
    typeof schema.shape === "function" ? schema.shape() : schema.shape;
  const lines = Object.entries(shape).map(([key, value]) => {
    const info = analyzeSchema(value, {
      registerLiteralUnion,
      propertyPath: [key],
    });
    const unionParts = info.typeParts.filter((part) => part !== "undefined");
    const union =
      unionParts.length === 0
        ? "unknown"
        : unionParts.length === 1
          ? unionParts[0]
          : unionParts.join(" | ");
    return `  ${key}${info.optional ? "?" : ""}: ${union};`;
  });

  const typeAliasDeclarations = Array.from(typeAliasRegistry.values()).map(
    ({ name, values, includeNull }) =>
      createTypeAlias(name, values, includeNull)
  );

  const sections = [
    ...typeAliasDeclarations,
    `export interface ${interfaceName} {\n${lines.join("\n")}\n}`,
  ].filter(Boolean);

  return sections.join("\n\n");
};

const buildDtoFiles = (schemaSources) =>
  schemaSources
    .map(({ modulePath, output }) => {
      const moduleExports = jiti(modulePath);
      const interfaceBlocks = Object.entries(moduleExports)
        .filter(([, exported]) => isZodObject(exported))
        .map(([exportName, schema]) =>
          buildInterface(schema, deriveDtoName(exportName))
        );

      if (interfaceBlocks.length === 0) {
        return undefined;
      }

      return {
        output,
        content: `${header}\n${interfaceBlocks.join("\n\n")}\n`,
      };
    })
    .filter(Boolean);

const writeDtos = async (files) => {
  await Promise.all(
    files.map(async ({ output, content }) => {
      await mkdir(path.dirname(output), { recursive: true });
      await writeFile(output, content, "utf8");
    })
  );
};

const main = async () => {
  try {
    const schemaSources = await discoverSchemaSources();
    if (schemaSources.length === 0) {
      console.warn(
        `No schema files found under ${path.relative(backendRoot, typesDir)}`
      );
      return;
    }

    const files = buildDtoFiles(schemaSources);
    if (files.length === 0) {
      console.warn("No Zod object schemas discovered. DTOs were not updated.");
      return;
    }

    await writeDtos(files);
    files.forEach(({ output }) => {
      console.log(`Generated DTO: ${path.relative(backendRoot, output)}`);
    });
  } catch (error) {
    console.error("Failed to generate DTOs:", error);
    process.exitCode = 1;
  }
};

await main();
